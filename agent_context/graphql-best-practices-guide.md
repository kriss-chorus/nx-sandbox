# GraphQL Best Practices Guide

> **⚠️ CRITICAL: Read the [GraphQL Architecture Guide](./graphql-architecture.md) FIRST to understand CRUD vs Domain graph separation. The CRUD graph is auto-generated by PostGraphile - you don't write resolvers for it!**

> **🎯 IMPORTANT: Always use PostGraphile CRUD queries first! Only create domain resolvers when CRUD truly cannot handle your use case (complex business rules, external API calls, etc.). PostGraphile handles filtering, ordering, pagination, and joins automatically.**

## 🏗️ Enterprise GraphQL Architecture Patterns

This guide provides comprehensive patterns for handling GraphQL operations in complex hierarchical data systems, derived from real-world implementations in enterprise applications. A key architectural principle is the separation of concerns between read-only query access and business logic operations through different GraphQL contexts.

> **Note**: For state management patterns related to GraphQL data, see the [State Management Guide](../frontend/state-management.md).

## 📝 NestJS Code-First GraphQL Approach

Our backend uses NestJS with a code-first approach to GraphQL schema generation. This means:

- **No manual schema files**: GraphQL schema is automatically generated from TypeScript decorators
- **Type safety**: TypeScript classes and decorators ensure type consistency between backend and GraphQL schema
- **Resolver-based architecture**: Each domain has its own resolver class with decorated methods
- **Input types as classes**: All GraphQL input types are defined as TypeScript classes with `@InputType()` decorator

### Code-First Patterns

```typescript
// Input types defined as classes
@InputType()
export class CreateEntityInput {
  @Field()
  name: string;

  @Field({ nullable: true })
  description?: string;
}

// Resolvers use decorators for queries and mutations
@Resolver('Entity')
export class EntityResolver {
  @Mutation(() => String)
  async createEntity(@Args('input') input: CreateEntityInput) {
    return await this.entityService.create(input);
  }

  @Query(() => Number)
  async entityCount() {
    return await this.entityService.getCount();
  }
}
```

## 🎯 API Context Strategy

### Domain vs CRUD Graph Separation

Our GraphQL architecture uses two distinct contexts to separate concerns:

- **CRUD Graph** (`context: { apiName: 'crud' }`): Auto-generated by PostGraphile from database schema
  - **USE THIS FIRST for 90% of your queries!**
  - Returns Relay-style connections with `nodes`, `edges`, `pageInfo`
  - Powerful filtering on any column with `filter` parameter
  - Built-in ordering with `orderBy`
  - Automatic pagination with `first`, `after`, etc.
  - Handles relationships and joins automatically
  - No custom resolvers needed - it's automatic!
- **Domain Graph** (`context: { apiName: 'domain' }`): Your custom resolvers with business logic
  - **Only use when CRUD cannot handle complexity**
  - Examples: multi-entity workflows, external API calls, complex authorization
  - All mutations go here for business validation
  - Can return simple arrays or custom shapes

```typescript
// ✅ Use CRUD graph for simple read operations (PostGraphile auto-generated)
const { data: entitiesData } = useQuery(GET_ALL_ENTITIES, {
  context: { apiName: 'crud' },
  fetchPolicy: 'network-only',
});
// Note: data.entities will be a connection with nodes!
const entities = data?.entities?.nodes || [];

// ✅ Use domain graph for all mutations with business rules
const [createEntity] = useMutation(CREATE_ENTITY, {
  context: { apiName: 'domain' },
});

// ✅ Special domain queries for complex business views (must use Relay pagination)
const { data: businessViewData } = useQuery(GET_BUSINESS_DASHBOARD_VIEW, {
  context: { apiName: 'domain' },
  fetchPolicy: 'network-only',
  variables: {
    first: 10,
    after: cursor, // Relay cursor-based pagination
  },
});
```

### When to Use Each Context

#### CRUD Graph (`crud`) - DEFAULT CHOICE

- **Start here for ALL read operations**
- Handles 90% of query needs automatically:
  - Filtering: `items(filter: { status: { equalTo: "active" }, ownerId: { equalTo: $userId } })`
  - Ordering: `records(orderBy: [CREATED_AT_DESC, NAME_ASC])`
  - Pagination: `data(first: 20, after: $cursor)`
  - Relationships: `facility { buildings { nodes { rooms { nodes { ... } } } } }`
  - Aggregations: PostGraphile can handle counts, sums, etc.
- No custom resolvers needed - PostGraphile generates everything

#### Domain Graph (`domain`) - ONLY WHEN NECESSARY

- All mutations (for business validation)
- Queries that CRUD truly cannot handle:
  - Complex multi-entity workflows
  - External API data integration
  - Business rules too complex for PostGraphile filters
  - Computed fields requiring external services
- Document WHY you couldn't use CRUD when creating domain resolvers

## 🔧 Core GraphQL Query Patterns

### GraphQL Codegen Syntax Requirement

**CRITICAL**: Always use `gql(``)` with parentheses for GraphQL codegen to generate proper TypeScript types:

```typescript
// ✅ Correct - Codegen can generate types
import { gql } from '@apollo/client';

const GET_USERS = gql(`
  query GetUsers {
    users {
      id
      name
    }
  }
`);

// ❌ Wrong - Codegen cannot generate types
const GET_USERS = gql`
  query GetUsers {
    users {
      id
      name
    }
  }
`;
```

### Basic Query Structure

```typescript
// ✅ CRUD graph for standard read operations
const {
  data: entitiesData,
  loading,
  error,
  refetch,
} = useQuery(GET_ALL_ENTITIES, {
  context: { apiName: 'crud' }, // Read-only data access
  fetchPolicy: 'network-only',
});

// Safe data extraction with fallbacks
const entities = entitiesData?.entities?.nodes?.filter(Boolean) || [];
```

### Related Data Queries

```typescript
// ✅ CRUD graph for relationship queries
const {
  data: childEntitiesData,
  loading,
  refetch: refetchChildren,
} = useQuery(GET_CHILD_ENTITIES, {
  context: { apiName: 'crud' }, // Read-only relationship data
  fetchPolicy: 'network-only',
});

// Type-safe data extraction
const childEntities: ChildEntity[] = childEntitiesData?.childEntities?.nodes || [];
```

### Conditional Queries

```typescript
// ✅ CRUD graph for conditional queries
const { data: dependentData, loading: dependentLoading } = useQuery(GET_DEPENDENT_ENTITIES, {
  variables: { parentId },
  context: { apiName: 'crud' }, // Read-only conditional data
  fetchPolicy: 'network-only',
  skip: !parentId, // Don't run if no parent selected
});

// ✅ CRUD graph for basic relationship queries
const { data: allRelatedData } = useQuery(GET_ALL_RELATED_ENTITIES, {
  context: { apiName: 'crud' }, // Read-only relationship data
  fetchPolicy: 'network-only',
});

const dependentEntities: DependentEntity[] = dependentData?.entities?.nodes || [];
```

### Complex Data Queries

```typescript
// ✅ CRUD graph for complex read operations
const { data: complexData } = useQuery(COMPLEX_ENTITY_QUERY, {
  context: { apiName: 'crud' }, // Read-only complex data
  fetchPolicy: 'network-only',
});

// ✅ Domain graph for business logic queries
const { data: businessData } = useQuery(GET_BUSINESS_ANALYTICS_VIEW, {
  context: { apiName: 'domain' }, // Business logic computation
  fetchPolicy: 'network-only',
});

// Transform complex data for UI consumption
const transformedEntities = transformEntityData(complexData?.entities?.nodes as Entity[]);
```

### Relay-Style Pagination with PostGraphile

```typescript
// ✅ CRUD graph with Relay pagination
const { data, loading, error, fetchMore } = useQuery(GET_ENTITIES_PAGINATED, {
  variables: {
    first: 20, // Initial page size
    after: null, // Start from beginning
  },
  context: { apiName: 'crud' },
  fetchPolicy: 'network-only',
});

// Extract Relay connection data
const entities = data?.entities?.nodes || [];
const pageInfo = data?.entities?.pageInfo;
const hasNextPage = pageInfo?.hasNextPage;
const endCursor = pageInfo?.endCursor;

// Load more data
const loadMore = async () => {
  if (!hasNextPage || loading) return;

  await fetchMore({
    variables: {
      first: 20,
      after: endCursor,
    },
    updateQuery: (previousResult, { fetchMoreResult }) => {
      if (!fetchMoreResult) return previousResult;

      return {
        entities: {
          ...fetchMoreResult.entities,
          nodes: [...previousResult.entities.nodes, ...fetchMoreResult.entities.nodes],
        },
      };
    },
  });
};
```

### Advanced Relay Pagination Patterns

```typescript
// Bidirectional pagination with first/last and after/before
const useBidirectionalPagination = (pageSize = 20) => {
  const [paginationVariables, setPaginationVariables] = useState({
    first: pageSize,
    after: null,
    last: null,
    before: null,
  });

  const { data, loading, error, fetchMore } = useQuery(GET_ENTITIES_PAGINATED, {
    variables: paginationVariables,
    context: { apiName: 'crud' },
    fetchPolicy: 'network-only',
  });

  const pageInfo = data?.entities?.pageInfo;

  const goToNextPage = async () => {
    if (!pageInfo?.hasNextPage) return;

    await fetchMore({
      variables: {
        first: pageSize,
        after: pageInfo.endCursor,
        last: null,
        before: null,
      },
      updateQuery: (_, { fetchMoreResult }) => fetchMoreResult,
    });
  };

  const goToPreviousPage = async () => {
    if (!pageInfo?.hasPreviousPage) return;

    await fetchMore({
      variables: {
        first: null,
        after: null,
        last: pageSize,
        before: pageInfo.startCursor,
      },
      updateQuery: (_, { fetchMoreResult }) => fetchMoreResult,
    });
  };

  return {
    entities: data?.entities?.nodes || [],
    pageInfo,
    loading,
    error,
    goToNextPage,
    goToPreviousPage,
  };
};
```

### Infinite Scroll with Relay Pagination

```typescript
const useInfiniteScroll = (pageSize = 20) => {
  const { data, loading, fetchMore } = useQuery(GET_ENTITIES_PAGINATED, {
    variables: { first: pageSize },
    context: { apiName: 'crud' },
    fetchPolicy: 'network-only',
  });

  const [isFetchingMore, setIsFetchingMore] = useState(false);

  const entities = data?.entities?.nodes || [];
  const pageInfo = data?.entities?.pageInfo;

  const loadMore = useCallback(async () => {
    if (!pageInfo?.hasNextPage || loading || isFetchingMore) return;

    setIsFetchingMore(true);

    try {
      await fetchMore({
        variables: {
          first: pageSize,
          after: pageInfo.endCursor,
        },
        updateQuery: (previousResult, { fetchMoreResult }) => {
          if (!fetchMoreResult) return previousResult;

          return {
            entities: {
              ...fetchMoreResult.entities,
              nodes: [...previousResult.entities.nodes, ...fetchMoreResult.entities.nodes],
            },
          };
        },
      });
    } finally {
      setIsFetchingMore(false);
    }
  }, [fetchMore, pageInfo, loading, isFetchingMore, pageSize]);

  // Auto-load when scrolling near bottom
  useEffect(() => {
    const handleScroll = () => {
      if (window.innerHeight + document.documentElement.scrollTop >= document.documentElement.offsetHeight - 1000) {
        loadMore();
      }
    };

    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, [loadMore]);

  return {
    entities,
    loading,
    isFetchingMore,
    hasNextPage: pageInfo?.hasNextPage,
    loadMore,
  };
};
```

## 🔄 Mutation Patterns

> **Note**: For managing UI state updates after mutations, see the [State Management Guide](../frontend/state-management.md).

### 1. Create Operations

```typescript
const [createEntity, { loading: createLoading }] = useMutation(CREATE_ENTITY, {
  context: { apiName: 'domain' }, // Business logic with validation
});

// Comprehensive create operation with proper error handling
const handleCreateEntity = async (formData: EntityInput) => {
  try {
    await createEntity({
      variables: {
        input: {
          id: v4(),
          name: formData.name,
          description: formData.description,
          // ... other fields
        },
      },
    });

    // Immediately refresh data after creation
    await refetchEntities();

    // Show success notification
    notifications.show('Entity created successfully', { severity: 'success', autoHideDuration: 3000 });
  } catch (error) {
    console.error('Error creating entity:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    notifications.show(`Error: ${errorMessage}`, { severity: 'error', autoHideDuration: 3000 });
  }
};
```

### 2. Update Operations

```typescript
// ✅ Domain graph for all mutations with business rules
const [updateEntity, { loading: updateLoading }] = useMutation(UPDATE_ENTITY, {
  context: { apiName: 'domain' }, // Business logic and validation
});

const handleSaveEdit = async () => {
  if (!editingName.trim()) {
    setError('Entity name cannot be empty');
    return;
  }

  try {
    await updateEntity({
      variables: {
        input: {
          entityId: editingEntityId,
          name: editingName,
          description: editingDescription,
        },
      },
    });

    // Reset editing state
    setEditingEntityId(undefined);
    setEditingName('');
    setError(undefined);

    // Refresh data with fresh fetch
    await refetchEntities();
  } catch (error) {
    console.error('Error updating entity:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    setError(errorMessage);
  }
};

// ✅ Domain graph enforces business rules and validation
const [updateChildEntity, { loading: updateLoading }] = useMutation(UPDATE_CHILD_ENTITY, {
  context: { apiName: 'domain' }, // Complex validation and business logic
});

const handleUpdateChildEntity = async (entityId: string, input: UpdateChildInput) => {
  try {
    await updateChildEntity({
      variables: {
        input: {
          entityId: entityId,
          name: input.name,
          capacity: input.capacity,
        },
      },
    });

    // Refresh related data after update
    await loadChildEntities();
    await refreshStatistics();

    notifications.show('Entity updated successfully', { severity: 'success', autoHideDuration: 3000 });
  } catch (error) {
    console.error('Error updating entity:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    notifications.show(`Error: ${errorMessage}`, { severity: 'error', autoHideDuration: 3000 });
  }
};
```

### 3. Delete Operations

```typescript
const [deleteEntity, { loading: deleteLoading }] = useMutation(DELETE_ENTITY, {
  context: { apiName: 'domain' }, // Business rules for deletion
});

const handleDeleteEntity = async (entityId: string) => {
  try {
    await deleteEntity({
      variables: {
        input: { id: entityId },
      },
    });

    // Refresh all related data
    await Promise.all([
      refetchEntities(),
      refetchChildEntities(), // Children might be affected
      refetchParentEntities(), // Parents might show child counts
    ]);

    notifications.show('Child entity updated successfully', { severity: 'success', autoHideDuration: 3000 });
  } catch (error) {
    console.error('Error deleting entity:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    notifications.show(`Error: ${errorMessage}`, { severity: 'error', autoHideDuration: 3000 });
  }
};
```

## 🔗 Hierarchical Data Management

### 1. Cascading Queries

```typescript
const HierarchicalDataManager = () => {
  const [selectedParentId, setSelectedParentId] = useState<string>('');
  const [selectedChildId, setSelectedChildId] = useState<string>('');

  // ✅ CRUD graph for parent entity reads
  const { data: parentData } = useQuery(GET_ALL_PARENTS, {
    context: { apiName: 'crud' }, // Read-only parent data
    fetchPolicy: 'network-only',
  });

  // ✅ CRUD graph for child entity reads
  const { data: childData, refetch: refetchChildren } = useQuery(GET_CHILDREN_BY_PARENT, {
    variables: { parentId: selectedParentId },
    context: { apiName: 'crud' }, // Read-only child data
    fetchPolicy: 'network-only',
    skip: !selectedParentId, // Don't run if no parent selected
  });

  // ✅ CRUD graph for grandchild entity reads
  const { data: grandchildData } = useQuery(GET_GRANDCHILDREN_BY_CHILD, {
    variables: { childId: selectedChildId },
    context: { apiName: 'crud' }, // Read-only grandchild data
    fetchPolicy: 'network-only',
    skip: !selectedChildId,
  });

  // Handle selection changes with proper state reset
  const handleParentChange = (parentId: string) => {
    setSelectedParentId(parentId);
    setSelectedChildId(''); // Reset dependent selections
  };
};
```

### 2. Complex Mutation Workflows

```typescript
const [assignItemToContainer, { loading: assignLoading }] = useMutation(ASSIGN_ITEM, {
  context: { apiName: 'domain' }, // Business logic for item assignment
});

const handleItemAssignment = async (itemId: string, containerId: string) => {
  try {
    await assignItemToContainer({
      variables: {
        input: {
          itemId,
          containerId,
          assignedAt: new Date().toISOString(),
        },
      },
    });

    // Refresh all affected data with fresh fetch
    await Promise.all([refetchItemsData(), refetchAssignments(), refetchAvailableItems()]);

    notifications.show('Item assigned successfully', { severity: 'success', autoHideDuration: 3000 });
  } catch (error) {
    console.error('Error assigning item:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    notifications.show(`Error: ${errorMessage}`, { severity: 'error', autoHideDuration: 3000 });
  }
};

// ✅ Domain graph validates capacity constraints
const [updateCapacity, { loading: updatingCapacity }] = useMutation(UPDATE_CAPACITY, {
  context: { apiName: 'domain' }, // Business rules prevent invalid capacity changes
});

const handleCapacityUpdate = async (entityId: string, newCapacity: number, entityName: string) => {
  try {
    await updateCapacity({
      variables: {
        input: {
          entityId,
          name: entityName,
          capacity: newCapacity,
        },
      },
    });

    // Refresh related data that depends on capacity
    await Promise.all([
      refetchEntities(),
      refetchSummaries(), // Summaries show capacity counts
      refetchStatistics(), // Overall statistics
    ]);

    notifications.show('Item assigned successfully', { severity: 'success', autoHideDuration: 3000 });
  } catch (error) {
    console.error('Error updating capacity:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';

    // Handle specific business logic errors
    if (errorMessage.includes('cannot reduce capacity')) {
      notifications.show('Cannot reduce capacity below current usage', { severity: 'warning', autoHideDuration: 3000 });
    } else {
      notifications.show(`Error: ${errorMessage}`, { severity: 'error', autoHideDuration: 3000 });
    }
  }
};
```

### 3. Refetching when a component doesn't unmount

```typescript

const EntityTableComponent = (props:Props) => {
  const { query } = props
  const {data, loading: entitiesLoading } = useQuery(query, {
    context: { apiName: 'crud' }, // Read-only data
    fetchPolicy: 'network-only'
  });

  return <BasicTable columns={columns} data={data} />
}

const EditEntityComponentModal = (props) => {
  const { queriesToRefetch = [] } = props
  const [isEditModalOpen, setIsEditModalOpen] = useState(false);
  const {data, loading: entitiesLoading } = useMutation(UPDATE_ENTITY, {
    context: { apiName: 'domain' }, // Mutations use domain graph
    refetchQueries: queriesToRefetch
  });

  return <Modal open={isEditModalOpen} data={data} />
}

const EntityManagementPage = () => {
  // the shared parent component should control the queries being called and refetched
  // this then allows for reuse
  return <div>
      <EntityTableComponent query={GET_ALL_ENTITIES} />
      <EditEntityComponentModal queriesToRefetch=[GET_ALL_ENTITIES] />
    </div>
}
```

## 🎨 UI Integration Patterns

### 1. Loading States

```typescript
const EntityLoadingComponent = () => {
  const { loading: entitiesLoading } = useQuery(GET_ALL_ENTITIES, {
    context: { apiName: 'crud' }, // Read-only data
    fetchPolicy: 'network-only'
  });

  const { loading: childEntitiesLoading } = useQuery(GET_ALL_CHILD_ENTITIES, {
    context: { apiName: 'crud' }, // Read-only data
    fetchPolicy: 'network-only'
  });

  const isLoading = entitiesLoading || childEntitiesLoading;

  if (isLoading) {
    return (
      <Box display="flex" justifyContent="center" p={3}>
        <CircularProgress />
        <Typography variant="body2" sx={{ ml: 2 }}>
          Loading data...
        </Typography>
      </Box>
    );
  }

  return <EntityManagementContent />;
};
```

### 2. Error Handling

```typescript
const EntityErrorBoundary = () => {
  const { error: entitiesError } = useQuery(GET_ALL_ENTITIES, {
    context: { apiName: 'crud' }, // Read-only data
    fetchPolicy: 'network-only'
  });

  const error = useEntityManagementState(s => s.error);

  if (entitiesError || error) {
    return (
      <Alert severity="error" sx={{ mb: 2 }}>
        <AlertTitle>Error Loading Data</AlertTitle>
        {entitiesError?.message || error}
        <Button
          onClick={() => window.location.reload()}
          size="small"
          sx={{ mt: 1 }}
        >
          Retry
        </Button>
      </Alert>
    );
  }

  return <EntityManagementContent />;
};
```

### 3. Real-time Data Synchronization

```typescript
const useRealTimeDataSync = () => {
  const updateState = useUpdateEntityManagementState();

  // Polling for real-time updates
  const { data, startPolling, stopPolling } = useQuery(GET_ALL_ENTITIES, {
    context: { apiName: 'crud' }, // Read-only polling
    fetchPolicy: 'network-only',
    pollInterval: 30000, // Poll every 30 seconds
  });

  // Update state when data changes
  useEffect(() => {
    if (data?.entities?.nodes) {
      updateState((draft) => {
        draft.entities = data.entities.nodes.filter(Boolean);
      });
    }
  }, [data, updateState]);

  useEffect(() => {
    // Start polling when component mounts
    startPolling(30000);

    return () => {
      // Stop polling when component unmounts
      stopPolling();
    };
  }, [startPolling, stopPolling]);
};
```

## 📄 Relay Pagination Utilities

### Connection Helpers

```typescript
// Extract nodes safely from Relay connection
export const getNodesFromConnection = <T>(connection: any): T[] => {
  return connection?.nodes?.filter(Boolean) || [];
};

// Extract page info safely
export const getPageInfoFromConnection = (connection: any) => {
  return (
    connection?.pageInfo || {
      hasNextPage: false,
      hasPreviousPage: false,
      startCursor: null,
      endCursor: null,
    }
  );
};

// Calculate total count when available
export const getTotalCountFromConnection = (connection: any): number | null => {
  return connection?.totalCount ?? null;
};

// Transform Relay connection to simple array with metadata
export const transformConnection = <T>(connection: any) => {
  return {
    nodes: getNodesFromConnection<T>(connection),
    pageInfo: getPageInfoFromConnection(connection),
    totalCount: getTotalCountFromConnection(connection),
  };
};
```

### Pagination State Management

```typescript
// Pagination state hook for complex scenarios
export const usePaginationState = (initialPageSize = 20) => {
  const [state, setState] = useState({
    pageSize: initialPageSize,
    currentCursor: null as string | null,
    direction: 'forward' as 'forward' | 'backward',
  });

  const buildVariables = () => {
    if (state.direction === 'forward') {
      return {
        first: state.pageSize,
        after: state.currentCursor,
        last: null,
        before: null,
      };
    } else {
      return {
        first: null,
        after: null,
        last: state.pageSize,
        before: state.currentCursor,
      };
    }
  };

  const goToNext = (endCursor: string) => {
    setState((prev) => ({
      ...prev,
      currentCursor: endCursor,
      direction: 'forward',
    }));
  };

  const goToPrevious = (startCursor: string) => {
    setState((prev) => ({
      ...prev,
      currentCursor: startCursor,
      direction: 'backward',
    }));
  };

  const reset = () => {
    setState({
      pageSize: initialPageSize,
      currentCursor: null,
      direction: 'forward',
    });
  };

  return {
    variables: buildVariables(),
    goToNext,
    goToPrevious,
    reset,
    currentPageSize: state.pageSize,
  };
};
```

## 🛠 Utility Functions

### 1. Data Transformation

```typescript
// Clean and transform entity data
export const cleanEntityData = (entity: any): Entity => ({
  id: entity.id,
  name: entity.name || '',
  description: entity.description || '',
  createdAt: entity.createdAt,
  updatedAt: entity.updatedAt,
  children: (entity.children?.nodes || []).filter(Boolean).map(cleanChildEntityData),
});

// Transform child entity data with parent relationships
export const cleanChildEntityData = (childEntity: any): ChildEntity => ({
  id: childEntity.id,
  name: childEntity.name || '',
  description: childEntity.description || '',
  parentId: childEntity.parentId,
  parent: childEntity.parent ? cleanEntityData(childEntity.parent) : undefined,
  grandchildren: (childEntity.grandchildren?.nodes || []).filter(Boolean).map(cleanGrandchildData),
});

// Transform data for UI display with computed properties
export const transformEntityData = (entities: Entity[]): TransformedEntity[] => {
  return (entities || []).filter(Boolean).map((entity) => ({
    ...entity,
    totalItems: entity.capacity || 0,
    usedItems: entity.assignments?.nodes?.filter((assignment) => assignment.item?.status === 'active').length || 0,
    availableItems: (entity.capacity || 0) - (entity.assignments?.nodes?.filter((assignment) => assignment.item?.status === 'active').length || 0),
    parent: entity.parent ? cleanEntityData(entity.parent) : undefined,
  }));
};

// Validate business rules before mutations
export const validateCapacityUpdate = (currentCapacity: number, newCapacity: number, currentUsage: number): { isValid: boolean; error?: string } => {
  if (newCapacity <= 0) {
    return { isValid: false, error: 'Capacity must be greater than 0' };
  }

  if (newCapacity < currentUsage) {
    return {
      isValid: false,
      error: `Cannot reduce capacity to ${newCapacity}. Currently using ${currentUsage} items.`,
    };
  }

  return { isValid: true };
};
```

### 2. Type Guards

```typescript
// Type guards for safe data access
export const isEntity = (item: any): item is Entity => {
  return item && typeof item.id === 'string' && typeof item.name === 'string';
};

export const isChildEntity = (item: any): item is ChildEntity => {
  return item && typeof item.id === 'string' && typeof item.parentId === 'string';
};

export const isValidEntityHierarchy = (entity: any): entity is Entity & { children: ChildEntity[] } => {
  return isEntity(entity) && Array.isArray(entity.children) && entity.children.every(isChildEntity);
};
```

## 🚀 Best Practices Summary

### Frontend Do's ✅

1. **Always use `fetchPolicy: 'network-only'`** after mutations to ensure fresh data
2. **Filter out null/undefined items** from GraphQL responses using `.filter(Boolean)`
3. **Provide comprehensive error handling** for all operations using try/catch blocks
4. **Implement proper loading states** for all async operations
5. **Refresh related data** after mutations that might affect multiple entities
6. **Use type guards** to ensure data safety and prevent runtime errors
7. **Clean and transform data** at the boundary between GraphQL and UI components
8. **Handle mutations with promises** rather than deprecated callback options
9. **Use domain graph for all mutations** that involve business logic and validation
10. **Use CRUD graph exclusively for read operations** to maintain clear separation
11. **Validate business rules** before making mutation calls when possible
12. **Use Promise.all()** for parallel data refreshes when multiple queries need updating
13. **Reset dependent state** when parent selections change in hierarchical data
14. **Use Relay cursor-based pagination** for consistent performance with large datasets
15. **Extract nodes from connections safely** using helper functions
16. **Implement proper fetchMore logic** with updateQuery for infinite scroll
17. **Handle pagination state properly** when navigating between pages

### Frontend Don'ts ❌

1. **Don't rely on Apollo cache** for critical real-time updates
2. **Don't ignore potential error scenarios** in GraphQL operations
3. **Don't leave loading states unhandled** in UI components
4. **Don't mutate state directly** - use immutable update patterns
5. **Don't forget to refresh dependent queries** after mutations
6. **Don't hardcode entity relationships** - use proper GraphQL relations
7. **Don't skip data validation** and type checking
8. **Don't use deprecated onCompleted/onError** - handle mutations with promises
9. **Don't use CRUD graph for mutations** - always use domain graph for write operations
10. **Don't use domain graph for simple reads** - use CRUD graph for basic data retrieval
11. **Don't bypass server-side validation** - let the domain graph enforce business rules
12. **Don't make assumptions about data structure** - always check for existence
13. **Don't forget to handle edge cases** in hierarchical data selections
14. **Don't use offset-based pagination** with PostGraphile - use cursor-based instead
15. **Don't ignore pageInfo** when implementing pagination controls
16. **Don't concatenate pages incorrectly** - ensure proper updateQuery logic
17. **Don't fetch all data at once** for large datasets - implement proper pagination

### Backend (NestJS) Do's ✅

1. **Use @InputType() decorator** for all GraphQL input classes
2. **Use @Field() decorator** with proper types and options (nullable, description)
3. **Separate DTOs from GraphQL input types** - use plain classes for internal service DTOs
4. **Use ScopedDrizzleService.runWithContext** for all transactional operations (insert/update/delete)
5. **Use ScopedDrizzleService.db** for read-only queries - unless SET LOCAL is required.
6. **Inject dependencies using hard-private fields** (e.g., `readonly #service: Service`)
7. **Return entity IDs from mutations** for frontend to track and refresh data
8. **Use invariant() for validation** with clear error messages
9. **Implement proper soft deletes** using deletedAt timestamps
10. **Clean up test data properly** in integration tests with afterEach hooks
11. **Use UUID suffix for test data names** to prevent collisions in parallel tests
12. **Track test entity IDs** for proper cleanup after each test
13. **Use NestJS Test Module** with DBModule.forTest() for integration tests
14. **Validate entity existence** before performing operations
15. **Check for existing relationships** before creating new ones
16. **Use transactions for multi-step operations** to ensure data consistency
17. **Handle cascade operations properly** in the correct dependency order

### Backend (NestJS) Don'ts ❌

1. **Don't use @ObjectType() for input types** - use @InputType() instead
2. **Don't mix GraphQL decorators with service logic** - keep resolvers thin
3. **Don't perform raw database operations** without proper transaction context
4. **Don't use insert/update/delete without runWithContext** transaction wrapper
5. **Don't expose internal DTOs in GraphQL schema** - create specific input types
6. **Don't skip entity existence validation** before operations
7. **Don't hardcode test data without unique identifiers** - use UUID suffixes
8. **Don't leave test data in database** - always clean up in afterEach
9. **Don't ignore foreign key constraints** - validate related entities exist
10. **Don't use public fields for injected services** - use hard-private with #
11. **Don't return complex objects from mutations** - return IDs and let frontend query
12. **Don't skip business rule validation** in service methods
13. **Don't mix read and write operations** in the same transaction unnecessarily
14. **Don't forget to handle soft deletes** when querying data
15. **Don't create circular dependencies** between services
16. **Don't expose database errors directly** - wrap with business-friendly messages
17. **Don't skip integration tests** for critical business operations

### Performance Considerations 🚀

1. **Use query skipping** for conditional queries based on user selections
2. **Implement Relay-style pagination** for large datasets with proper cursor management
3. **Batch related mutations** when possible to reduce server round trips
4. **Use polling judiciously** - balance real-time updates with performance
5. **Cache transformed data** in state when expensive computations are involved
6. **Debounce search/filter operations** to reduce query frequency
7. **Keep mutations simple** - avoid optimistic updates until absolutely necessary
8. **Use Promise.all()** for parallel data refreshes after mutations
9. **Implement proper query dependencies** with skip conditions
10. **Consider subscription patterns** for real-time data that changes frequently
11. **Leverage PostGraphile's cursor-based pagination** for consistent performance
12. **Use appropriate page sizes** - balance UX and performance (typically 10-50 items)
13. **Implement virtual scrolling** for very large datasets with infinite scroll

This guide provides a comprehensive foundation for managing complex hierarchical data using GraphQL with proper state management, error handling, and real-time synchronization patterns that can be applied to any domain.
