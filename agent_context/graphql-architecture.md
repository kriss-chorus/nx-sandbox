# GraphQL Architecture Guide

## Overview

This guide explains the dual GraphQL API architecture used in our platform, which consists of:
1. **CRUD Graph** - Auto-generated by PostGraphile from database schema (USE THIS FIRST!)
2. **Domain Graph** - Custom resolvers with business logic (ONLY when CRUD can't handle complexity)

## Core Principle: CRUD First, Domain When Necessary

**Always start with PostGraphile CRUD queries.** They automatically provide:
- Filtering on any column
- Ordering
- Pagination
- Relationships
- Aggregations

Only create domain resolvers when PostGraphile cannot handle:
- Complex business rules
- Multi-entity workflows
- Computed fields requiring external services
- User-specific data filtering that can't be done with RLS

## Key Architecture Concepts

### CRUD Graph (PostGraphile)

The CRUD graph is **automatically generated** by PostGraphile based on your database schema. It provides:

- **Automatic Relay-style connections** for all tables
- **Built-in filtering, ordering, and pagination**
- **No custom business logic** - direct database access
- **Read-only operations** recommended

#### Important CRUD Graph Characteristics

1. **Connection-based responses** - All list queries return connections with `nodes`, `edges`, `pageInfo`
2. **Auto-generated types** - Filter types follow pattern: `TableNameFilter` (not `TableNameFilterInput`)
3. **No custom resolvers needed** - PostGraphile handles everything
4. **RLS (Row Level Security)** - Database-level security if configured

#### CRUD Query Example

```typescript
// ✅ Correct - CRUD graph query with PostGraphile connection
const GET_FACILITIES = gql(`
  query GetFacilities($first: Int, $after: Cursor, $filter: FacilityFilter) {
    facilities(first: $first, after: $after, filter: $filter) {
      nodes {
        id
        name
        description
      }
      pageInfo {
        hasNextPage
        endCursor
      }
      totalCount
    }
  }
`);

// ❌ Wrong - Don't expect array response from CRUD graph
const GET_FACILITIES = gql(`
  query GetFacilities {
    facilities {  // This returns a connection, not an array!
      id
      name
    }
  }
`);

// ❌ Wrong - Don't use gql`` without parentheses
const GET_FACILITIES = gql`
  query GetFacilities {
    facilities { nodes { id } }
  }
`;  // Codegen won't generate types!
```

### Domain Graph (Custom Resolvers)

The domain graph contains your **custom business logic** implemented in NestJS resolvers:

- **Business rule enforcement**
- **Complex queries with computed fields**
- **All mutations** (create, update, delete)
- **Custom authentication/authorization logic**
- **Cross-entity operations**

#### Domain Graph Patterns

```typescript
// Domain resolver with business logic
@Resolver(() => Tenant)
export class TenantResolver {
  @Query(() => [Tenant], { name: 'tenants' })
  async getTenants(
    @CurrentUser() userId: string,
    @Args('filter', { nullable: true }) filter?: TenantFilterInput,
  ): Promise<Tenant[]> {
    // Business logic: only return user's own tenants
    return await this.#tenantService.listTenants(userId, filter);
  }

  @Mutation(() => String, { name: 'createTenant' })
  async createTenant(
    @CurrentUser() userId: string,
    @Args('input') input: CreateTenantInput,
  ): Promise<string> {
    // Business logic: validation, subdomain uniqueness, etc.
    return await this.#tenantService.createTenant(input, userId);
  }
}
```

## Common Pitfalls and Solutions

### Pitfall 1: Querying Wrong Graph

**Problem**: Trying to query custom resolver through CRUD graph
```typescript
// ❌ Wrong - Custom resolver doesn't exist in CRUD graph
const { data } = useQuery(GET_TENANTS, {
  context: { apiName: 'crud' },  // PostGraphile doesn't know about your resolver!
});
```

**Solution**: Use the correct graph
```typescript
// ✅ Correct - Query custom resolver through domain graph
const { data } = useQuery(GET_TENANTS, {
  context: { apiName: 'domain' },
});
```

### Pitfall 2: Expecting Wrong Response Format

**Problem**: CRUD graph always returns connections, not arrays
```typescript
// ❌ Wrong - CRUD returns connection, not array
const tenants = data?.tenants || [];  // undefined, tenants is a connection!
```

**Solution**: Access nodes from connection
```typescript
// ✅ Correct - Extract nodes from connection
const tenants = data?.tenants?.nodes || [];
```

### Pitfall 3: Wrong Filter Type Names

**Problem**: Using custom input type names with PostGraphile
```graphql
# ❌ Wrong - PostGraphile doesn't generate "Input" suffix
query GetTenants($filter: TenantFilterInput) {
  tenants(filter: $filter) { ... }
}
```

**Solution**: Use PostGraphile's naming convention
```graphql
# ✅ Correct - PostGraphile uses TableNameFilter
query GetTenants($filter: TenantFilter) {
  tenants(filter: $filter) { ... }
}
```

## Decision Tree: CRUD vs Domain

```
Need to query data?
├─ Can PostGraphile handle it with filters/joins?
│  ├─ Yes → Use CRUD graph (90% of cases!)
│  └─ No → Continue
├─ Need complex business logic that PostGraphile can't express?
│  ├─ Yes → Create Domain resolver
│  └─ No → Use CRUD graph with filters
├─ Need computed fields from external services?
│  ├─ Yes → Create Domain resolver
│  └─ No → Use CRUD graph
└─ Is it a mutation?
   └─ Use Domain graph for business validation
```

### Examples: When to Use Each

**Use CRUD Graph:**
- Get all tenants: `tenants { nodes { ... } }`
- Filter by owner: `tenants(filter: { ownerId: { equalTo: $userId } })`
- Get active items: `items(filter: { isActive: { equalTo: true } })`
- Order by date: `records(orderBy: CREATED_AT_DESC)`
- Paginate results: `data(first: 20, after: $cursor)`
- Join relations: `facility { buildings { nodes { ... } } }`

**Use Domain Graph Only When:**
- Complex authorization rules beyond RLS
- Multi-step workflows (e.g., create order + inventory + notification)
- External API calls for computed data
- Business rules too complex for PostGraphile filters

## Implementation Checklist

### When Adding New Database Tables

1. **Database Migration**
   ```bash
   pnpm nx run @platform/your-api:migrate:generate
   pnpm nx run @platform/your-api:migrate:up
   ```

2. **CRUD Graph** (Automatic)
   - Table is immediately available in CRUD graph
   - Filter types are auto-generated as `TableNameFilter`
   - Connections with nodes/edges/pageInfo are created
   - No resolver needed

3. **Domain Graph** (If needed)
   - Create service with business logic
   - Create resolver for custom queries/mutations
   - Define GraphQL types with `@ObjectType()` and `@InputType()`
   - Add to module providers

### When Querying Data

1. **Identify the graph to use**
   - Simple reads → CRUD graph
   - Business logic → Domain graph
   - Mutations → Always Domain graph

2. **Write the query**
   ```typescript
   // CRUD graph query (with connection)
   const GET_ITEMS = gql(`
     query GetItems {
       items {
         nodes { id, name }
         totalCount
       }
     }
   `);

   // Domain graph query (custom shape)
   const GET_USER_ITEMS = gql(`
     query GetUserItems {
       userItems {  # Custom resolver
         id
         name
         computedField
       }
     }
   `);
   ```

3. **Use correct context**
   ```typescript
   const { data } = useQuery(GET_ITEMS, {
     context: { apiName: 'crud' },    // or 'domain'
     fetchPolicy: 'network-only',
   });
   ```

## Real Example: Tenant Management

### What PostGraphile Generates (CRUD)

From the `tenant` table, PostGraphile automatically creates:
- `tenants` query with `TenantsConnection` return type
- `TenantFilter` input type
- `TenantsOrderBy` enum
- Full Relay pagination support

### What We Implement (Domain)

Custom resolver for business logic:
- Filter tenants by authenticated user
- Validate subdomain uniqueness
- Enforce business rules on mutations

```typescript
// Frontend: Use domain graph for user-filtered data
const { data } = useQuery(GET_TENANTS, {
  context: { apiName: 'domain' },  // Our custom resolver
});

const tenants = data?.tenants || [];  // Simple array from our resolver
```

## Best Practices

1. **Always use gql(``)** - Required for GraphQL codegen to generate TypeScript types
2. **Start with CRUD always** - PostGraphile is more powerful than you think
3. **Avoid custom resolvers** - Only create them when CRUD truly can't handle it
4. **Use PostGraphile filters** - They're auto-generated and handle most cases
5. **Keep mutations in Domain** - Business validation belongs in custom code
6. **Match the response format** - CRUD = connections, Domain = your choice
7. **Use correct filter types** - `TableFilter` not `TableFilterInput` for CRUD
8. **Document why** - If you create a domain resolver, comment why CRUD wasn't sufficient

## Common Patterns Reference

### CRUD Graph Patterns (PostGraphile)
- `facilities { nodes { ... } }`
- `facility(id: $id) { ... }`
- `filter: { isActive: { equalTo: true } }`
- `orderBy: [CREATED_AT_DESC]`
- `first: 20, after: $cursor`

### Domain Graph Patterns (Custom)
- `@Query(() => [Entity])` - Return arrays
- `@Mutation(() => String)` - Return IDs
- `@Args('input') input: CreateInput` - Custom inputs
- `@CurrentUser() userId: string` - Auth context
- Business logic in services, not resolvers